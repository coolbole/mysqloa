<?xml version="1.0" encoding="UTF-8"?>
<list>

 <MySQLVariableDescription>
	<variable_name>Innodb_buffer_pool_read_ahead_seq</variable_name>
	<description>InnoDB初始化的顺序read-aheads数。当InnoDB执行顺序全表扫描时发生。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_buffer_pool_read_requests</variable_name>
	<description>InnoDB已经完成的逻辑读请求数。</description>
</MySQLVariableDescription>
 
 <MySQLVariableDescription>
	<variable_name>Innodb_buffer_pool_reads</variable_name>
	<description>不能满足InnoDB必须单页读取的缓冲池中的逻辑读数量。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_buffer_pool_wait_free</variable_name>
	<description>一般情况，通过后台向InnoDB缓冲池写。但是，如果需要读或创建页，并且没有干净的页可用，则它还需要先等待页面清空。
该计数器对等待实例进行记数。如果已经适当设置缓冲池大小，该值应小。</description>
</MySQLVariableDescription>

<MySQLVariableDescription>
	<variable_name>Innodb_buffer_pool_pages_total</variable_name>
	<description>缓冲池总大小（页数）。</description>
</MySQLVariableDescription>

<MySQLVariableDescription>
	<variable_name>Innodb_buffer_pool_pages_misc</variable_name>
	<description>忙的页数，因为它们已经被分配优先用作管理，例如行锁定或适用的哈希索引。
	该值还可以计算为 Innodb_buffer_pool_pages_total - Innodb_buffer_pool_pages_free - Innodb_buffer_pool_pages_data。
	</description>
</MySQLVariableDescription>

<MySQLVariableDescription>
	<variable_name>Innodb_buffer_pool_pages_latched</variable_name>
	<description>在InnoDB缓冲池中锁定的页数。这是当前正读或写或由于其它原因不能清空或删除的页数。</description>
</MySQLVariableDescription>

<MySQLVariableDescription>
	<variable_name>Innodb_buffer_pool_pages_free</variable_name>
	<description>缓存池中空的页数。</description>
</MySQLVariableDescription>

<MySQLVariableDescription>
	<variable_name>Innodb_buffer_pool_pages_flushed</variable_name>
	<description>要求清空的缓冲池页数。</description>
</MySQLVariableDescription>

<MySQLVariableDescription>
	<variable_name>Innodb_buffer_pool_pages_dirty</variable_name>
	<description>当前的脏页数。</description>
</MySQLVariableDescription>

<MySQLVariableDescription>
	<variable_name>Innodb_buffer_pool_pages_data</variable_name>
	<description>包含数据的页数(脏或干净)。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_buffer_pool_read_ahead_rnd</variable_name>
	<description>InnoDB初始化的“随机”read-aheads数。当查询以随机顺序扫描表的一大部分时发生。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_row_lock_time_avg</variable_name>
	<description>行锁定的平均时间，单位毫秒。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_rows_updated</variable_name>
	<description>InnoDB表内更新的行数。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_buffer_pool_write_requests</variable_name>
	<description>向InnoDB缓冲池的写数量。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_data_reads</variable_name>
	<description>数据读总数量。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_data_read</variable_name>
	<description>至此已经读取的数据数量（字节）。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_data_pending_writes</variable_name>
	<description>当前挂起的写数。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_data_pending_reads</variable_name>
	<description>当前挂起的读数。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_data_pending_fsyncs</variable_name>
	<description>待审fsync()数目fsync()操作。 Added in MySQL 5.0.2.新增在MySQL 5.0.2。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_dblwr_writes</variable_name>
	<description>已经执行的双写操作数量和为此目的已经写好的页数。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_row_lock_time</variable_name>
	<description>行锁定花费的总时间，单位毫秒。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_os_log_written</variable_name>
	<description>写入日志文件的字节数。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_os_log_pending_writes</variable_name>
	<description>挂起的日志文件写操作。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_os_log_pending_fsyncs</variable_name>
	<description>挂起的日志文件fsync()操作数量。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_os_log_fsyncs</variable_name>
	<description>向日志文件完成的fsync()写数量。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_log_waits</variable_name>
	<description>我们必须等待的时间，因为日志缓冲区太小，我们在继续前必须先等待对它清空。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_log_writes</variable_name>
	<description>向日志文件的物理写数量。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_log_write_requests</variable_name>
	<description>日志写请求数。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_dblwr_pages_written</variable_name>
	<description>已经执行的双写操作数量和为此目的已经写好的页数。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_data_written</variable_name>
	<description>至此已经写入的数据量（字节）。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_data_writes</variable_name>
	<description>数据写总数量。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_row_lock_time_max</variable_name>
	<description>行锁定的最长时间，单位毫秒。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_row_lock_time_avg</variable_name>
	<description>行锁定的平均时间，单位毫秒。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_pages_written</variable_name>
	<description>写入的页数。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_pages_read</variable_name>
	<description>读取的页数。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_pages_created</variable_name>
	<description>创建的页数。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_page_size</variable_name>
	<description>编译的InnoDB页大小(默认16KB)。许多值用页来记数；页的大小很容易转换为字节。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_row_lock_current_waits</variable_name>
	<description>当前等待的待锁定的行数。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_row_lock_waits</variable_name>
	<description>一行锁定必须等待的时间数。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_rows_inserted</variable_name>
	<description>插入到InnoDB表的行数。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_rows_read</variable_name>
	<description>从InnoDB表读取的行数。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Innodb_rows_deleted</variable_name>
	<description>从InnoDB表删除的行数。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Aborted_clients</variable_name>
	<description>（放弃客户端）状态变量。指出由于某种原因客户程序不能正常关闭连接而导致失败的连接的数量。
	如果客户不在退出之前调整mysql_close()函数，wait_timeout或interactive_timeout的限制已经被超出，或者是客户端程序在传输的过程中被关闭，则这种情况会发生</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Binlog_cache_disk_use</variable_name>
	<description>所使用的二进制日志缓存溢出到磁盘上的文件大小 </description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Binlog_cache_use</variable_name>
	<description>使用的二进制日志缓存大小</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Bytes_received</variable_name>
	<description>服务器收到的字节数量</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Bytes_sent</variable_name>
	<description>服务器发送的字节数量</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Qcache_free_blocks</variable_name>
	<description>缓存中相邻内存块的个数。数目大说明可能有碎片。FLUSH QUERY CACHE会对缓存中的碎片进行整理，从而得到一个空闲块。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Qcache_free_memory</variable_name>
	<description> 表示缓存中的空闲内存。</description>
</MySQLVariableDescription>


 <MySQLVariableDescription>
	<variable_name>Qcache_hits</variable_name>
	<description> 表示每次查询在缓存中命中时就增大</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Qcache_inserts</variable_name>
	<description>每次插入一个查询时就增大。命中次数除以插入次数就是不中比率。</description>
</MySQLVariableDescription>

　　
 <MySQLVariableDescription>
	<variable_name>Qcache_lowmem_prunes</variable_name>
	<description>缓存出现内存不足并且必须要进行清理以便为更多查询提供空间的次数。
	这个数字最好长时间来看；如果这个数字在不断增长，就表示可能碎片非常严重，或者内存很少。（上面的 free_blocks和free_memory可以告诉您属于哪种情况）</description>
</MySQLVariableDescription>

<MySQLVariableDescription>
	<variable_name>Qcache_not_cached</variable_name>
	<description> 不适合进行缓存的查询的数量，通常是由于这些查询不是 SELECT 语句或者用了now()之类的函数。</description>
</MySQLVariableDescription>
　　
<MySQLVariableDescription>
	<variable_name>Qcache_queries_in_cache</variable_name>
	<description>当前缓存的查询（和响应）的数量。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Qcache_total_blocks</variable_name>
	<description> 缓存中块的数量。</description>
</MySQLVariableDescription>

<MySQLVariableDescription>
	<variable_name>Open_tables</variable_name>
	<description>表示打开表的数量</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Opened_tables</variable_name>
	<description>Opened_tables表示打开过的表数量，如果Opened_tables数量过大，说明配置中table_cache(5.1.3之后这个值叫做table_open_cache)值可能太小，
	比较合适的值为：
		Open_tables / Opened_tables * 100% >= 85%
		Open_tables / table_cache * 100% = 95%
	</description>
</MySQLVariableDescription>

<MySQLVariableDescription>
	<variable_name>Rpl_status</variable_name>
	<description>失败状态的安全复制  （这个变量只在MYSQL 4之后版本使用）</description>
</MySQLVariableDescription>

<MySQLVariableDescription>
	<variable_name>Aborted_connects</variable_name>
	<description>指出试图连接到MYSQL的失败的次数。这种情况在客户尝试用错误的密码进行连接时，
没有权限进行连接时，为获得连接的数据包所花费的时间超过了connect_timeout限制的秒数，或数据包中没有包含正确的信息时，都会发生。</description>
</MySQLVariableDescription>

<MySQLVariableDescription>
	<variable_name>Connections</variable_name>
	<description>试图连接到MYSQL服务器的次数。</description>
</MySQLVariableDescription>

<MySQLVariableDescription>
	<variable_name>Key_read_requests</variable_name>
	<description>引起从键的缓存读取键的数据块的请求的数量。Key_reads与Key_read_requests的比率不应该高于1：100（也就是，1：10很糟糕）
	请求在内存中没有找到直接从硬盘读取索引，计算索引未命中缓存的概率：key_cache_miss_rate=Key_reads / Key_read_requests * 100%</description>
</MySQLVariableDescription>

<MySQLVariableDescription>
	<variable_name>Key_reads</variable_name>
	<description> 引起从磁盘读取键的数据块的物理读取操作的数量。</description>
</MySQLVariableDescription>

<MySQLVariableDescription>
	<variable_name>Key_write_requests</variable_name>
	<description> 引起键的数据块被写入缓存的请求的数量</description>
</MySQLVariableDescription>

<MySQLVariableDescription>
	<variable_name>Key_writes</variable_name>
	<description>向磁盘写入键的数据块的物理写操作的次数</description>
</MySQLVariableDescription>

<MySQLVariableDescription>
	<variable_name>Max_used_connections</variable_name>
	<description> 在任意时刻，正在使用的连接的最大数量</description>
</MySQLVariableDescription>


<MySQLVariableDescription>
	<variable_name>Not_flushed_key_blocks</variable_name>
	<description> 在键的缓存中，已经发生了改变但还没有被刷新到磁盘上的键的数据块的数量</description>
</MySQLVariableDescription>

<MySQLVariableDescription>
	<variable_name>Not_flushed_delayed_rows</variable_name>
	<description>当前在INSERT DELAY队列中，等待被写入的记录的个数</description>
</MySQLVariableDescription>

<MySQLVariableDescription>
	<variable_name>Created_tmp_tables</variable_name>
	<description> 执行语句时，内存中生成的隐含临时表的数量，服务器执行语句时自动创建的内存中的临时表的数量。
如果Created_tmp_disk_tables较大，你可能要增加tmp_table_size值使临时 表基于内存而不基于硬盘。</description>
</MySQLVariableDescription>

<MySQLVariableDescription>
	<variable_name>Created_tmp_files</variable_name>
	<description> 由mysqld生成的临时文件的数量,要注意该变量的数值，越小越好，最好为零</description>
</MySQLVariableDescription>

<MySQLVariableDescription>
	<variable_name>Created_tmp_disk_tables</variable_name>
	<description>  执行语句时，磁盘上生成的隐含临时表的数量,要注意该变量的数值，越小越好，最好为零</description>
</MySQLVariableDescription>

<MySQLVariableDescription>
	<variable_name>Uptime</variable_name>
	<description>  数据库服务器一共运行了多少时间</description>
</MySQLVariableDescription>

<MySQLVariableDescription>
	<variable_name>Uptime_since_flush_status</variable_name>
	<description> 自最近FLUSH STATUS声明的秒数。MySQL only Community 5.0.35 这个版本中添加了这个 变量。</description>
</MySQLVariableDescription>

<MySQLVariableDescription>
	<variable_name>Prepared_stmt_count</variable_name>
	<description>在事先准备好的执行SQL的数目。  （设定这个值的变量是max_prepared_stmt_count，MySQL 5.0.32版本中加入的。）</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Slave_running</variable_name>
	<description>这是ON如果此服务器是一个复制主/从复制的主，并且表示都在运行I / O和SQL线程 ，否则，它是OFF。</description>
</MySQLVariableDescription>
 
  <MySQLVariableDescription>
	<variable_name>Key_blocks_not_flushed</variable_name>
	<description>关键的缓存已经发生的变化数字，但关键块尚未刷新到磁盘。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Key_blocks_unused</variable_name>
	<description>在一些关键的未使用的缓存块。  您可以使用此值来确定如何关键缓存大量使用的;</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Key_blocks_used</variable_name>
	<description>在关键的缓存使用的块数。 此值是一个高水位标记，表明该使用过一次了块的最大数目。</description>
</MySQLVariableDescription>
 
<MySQLVariableDescription>
	<variable_name>Questions</variable_name>
	<description>该服务器所执行的语句数目， 这仅包括报表发送到服务器的客户和不包括在存储程序执行的语句，
	但是包含系统内部自己检测时说调用过的SQL次数在MySQL 5.0.72后的版本中添加。</description>
</MySQLVariableDescription>

<MySQLVariableDescription>
	<variable_name>Compression</variable_name>
	<description>无论客户端连接使用压缩在客户端/服务器协议 这个值都将能告诉你。使用表示ON，未使用表示OFF。</description>
</MySQLVariableDescription>

<MySQLVariableDescription>
	<variable_name>Select_full_join</variable_name>
	<description>执行join语句联接表扫描数，因为它们不使用索引。 如果该值不为0，你应该仔细检查你的表的索引。和 Select_scan 差不多，区别是 Select_full_join 代表的是第二张及之后的表。
	explain 中的类型也是 ALL，原因是表联接所用的字段上没有索引。它对性能有更为严重的影响，绝对要避免，所以用于联接的字段上一般都要加索引。</description>
</MySQLVariableDescription>
 
 <MySQLVariableDescription>
	<variable_name>Select_range</variable_name>
	<description>代表需要从硬盘读表在一段范围内的行。在 explain 中显示为 range，说明使用了索引查找记录在硬盘上的位置。
	关于第一个表使用范围。 这通常不是一个严重的问题，即使是相当大的价值也不必去关心。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Select_range_check</variable_name>
	<description>表示在执行JOIN 语句时没有使用过索引或者主键，如果这不是0，你应该仔细检查你的表的索引。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Select_scan</variable_name>
	<description>做了多少次全表扫描</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Threads_running</variable_name>
	<description> 该线程数目是当前正在运行的线程数，不是休眠状态的。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Threads_cached</variable_name>
	<description>在线程缓存线程数。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Threads_connected</variable_name>
	<description>在当前打开的连接数。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Threads_created</variable_name>
	<description>在创建的处理连接的线程数。  如果Threads_created过大，可能要增加thread_cache_size价值。 </description>
</MySQLVariableDescription>
 
 <MySQLVariableDescription>
	<variable_name>Tc_log_page_waits</variable_name>
	<description>For the memory-mapped implementation of the recovery log, this variable increments each time the server was not able to
 commit a transaction and had to wait for a free page in the log.
 对于内存映射的恢复日志的实施策略，这每一次的服务器变量的增量无法提交事务，并为自由等待页在日志中。
  If this value is large, you might want to increase the log size (with the --log-tc-size option).
  如果该值很大，您可能希望增加日志的大小（与--log-tc-size选项）。
   For binary log-based recovery, this variable increments each time the binary log cannot be closed because there are two-phase
   commits in progress.
    对于二进制日志的复苏，这个变量递增每次二进制日志不能被关闭，因为有两个阶段提交的进展情况。 
 (The close operation waits until all such transactions are finished.) Added in MySQL 5.0.3. 
（在关闭操作等待，直到所有这类交易完成。）新增在MySQL 5.0.3。  </description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Table_locks_waited</variable_name>
	<description>这个次数表锁请求的等待值是必要的，如果这是高，可能会有性能问题，您应该首先优化查询，然后去分析您的表或表或使用数据同步的机制。  </description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Handler_commit</variable_name>
	<description>内部COMMIT语句数目。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Handler_delete</variable_name>
	<description>记录有多少条记录被删除过 。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Handler_discover</variable_name>
	<description>MySQL服务器可以问NDB CLUSTER存储引擎是否知道某一名字的表。这被称作发现。Handler_discover说明通过该方法发现的次数。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Handler_prepare</variable_name>
	<description> 一个准备阶段的两阶段提交业务柜台。 Added in MySQL 5.0.3.新增在MySQL 5.0.3。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Handler_read_first</variable_name>
	<description>在时代的第一个条目索引人数为阅读。 如果该值为高，它表明该服务器是做了充分的索引扫描很多，例如， SELECT col1 FROM foo假设col1的索引。
	</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Handler_read_key</variable_name>
	<description> 请求数来读取一个关键的一排。 如果该值为高，这是一个好迹象表明，你的表是正确的您的查询索引。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Handler_read_next</variable_name>
	<description>按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加。
请求数来读取主键以便下一行。  此值递增，如果您要查询的范围约束的列或索引，如果你正在做一个索引扫描。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Handler_read_prev</variable_name>
	<description> 请求数来读取键顺序前一行。读法，这主要是用于优化ORDER BY ... DESC ORDER BY ... DESC . ORDER BY ... DESC 。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Handler_read_rnd</variable_name>
	<description> 请求数来读取一个固定位置的一排。 如果此值高，如果你正在做的查询，需要很多的结果排序。 
说明你可能有很多质疑的要求MySQL扫描整个表或您已加入不使用钥匙正确,根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。
你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Handler_read_rnd_next</variable_name>
	<description>请求数来读取数据文件的下一行。这个值高，如果你是做了很多表扫描。一般来说这表明您的表不正确索引或者您的查询不写入利用优势索引你。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Handler_rollback</variable_name>
	<description> 请求存储引擎执行回滚的操作数 。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Handler_savepoint</variable_name>
	<description>存储引擎放置一个保存点的请求数量。 新增在MySQL 5.0.3。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Handler_savepoint_rollback</variable_name>
	<description> 为存储引擎请求回滚到保存点数量。 Added in MySQL 5.0.3.新增在MySQL 5.0.3。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Handler_update</variable_name>
	<description> 记录请求更新表中的行数。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Handler_write</variable_name>
	<description>请求插入表中的行数。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Last_query_cost</variable_name>
	<description>用查询优化器计算的最后编译的查询的总成本。用于对比同一查询的不同查询方案的成本。默认值0表示还没有编译查询。 默认值是0。Last_query_cost具有会话范围。
  在默认值0表示没有查询已编制尚未。加入这个变量是在MySQL 5.0.1，其默认值为-1。在MySQL 5.0.7，默认已更改为0;  不是全局性的。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Open_files</variable_name>
	<description>默认是开启的。这一数字只包括由服务器打开普通文件。 它不包括诸如套接字或管道其他类型的文件。
此外，数不包括文件的存储引擎公开使用自己的内部职能，而不是要在服务器级别这样做。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Table_locks_immediate</variable_name>
	<description>表锁请求获得批准的次数。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Delayed_errors</variable_name>
	<description>与INSERT DELAYED一些错误的发生（可能是duplicate key ）写入的记录数。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Delayed_insert_threads</variable_name>
	<description>使用数INSERT DELAYED处理线程。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Delayed_writes</variable_name>
	<description>在INSERT DELAYED写入的记录数。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Flush_commands</variable_name>
	<description>在执行FLUSH声明数目。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Sort_rows</variable_name>
	<description>排序的记录数。这代表了在第二步中被排序的记录的总数。
因为 Sort_range 和 Sort_scan 是一样的，所以这个值只是说明了有多少记录被排序，意思不大。 </description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Sort_scan</variable_name>
	<description>记录 排序表扫描的记录数。</description>
</MySQLVariableDescription>
  
 <MySQLVariableDescription>
	<variable_name>Tc_log_max_pages_used</variable_name>
	<description>对于内存映射认为是mysqld使用时，作为内部XA事务的恢复事务的协调员日志的落实，这个变量表示为日志使用的页面数量最多因为服务器启动。
 如果Tc_log_max_pages_used产品和Tc_log_page_size总是大大低于日志大小少，规模大于必需的，可以减少。
 大小则是由--log-tc-size选项。目前，这个变量是未使用的：这是不必要的二进制日志的复苏，内存映射方法恢复日志，
否则不得使用的存储引擎的数目可两阶段提交大于InnoDB是只适用于引擎。）在MySQL 5.0.3新增。</description>
</MySQLVariableDescription>

 <MySQLVariableDescription>
	<variable_name>Tc_log_page_size</variable_name>
	<description>页面大小的内存使用映射的执行情况的XA恢复日志。默认值取决于使用。
目前，这个变量是未使用的为同样的原因描述的Tc_log_max_pages_used Added in MySQL 5.0.3.新增在MySQL 5.0.3。。</description>
</MySQLVariableDescription>
   
 <MySQLVariableDescription>
	<variable_name>Slow_queries</variable_name>
	<description>记录查询过程中是否有超过long_query_time设置的秒数的数量。执行时间超过2秒的即为慢查询，你可以分析慢查询日志，
找出有问题的SQL语句，慢查询时间不宜设置过长，否则意义不大，最好在5秒以内，
如果你需要微秒级别的慢查询，可以考虑给MySQL打补丁：http://www.percona.com /docs/wiki/release:start，记得找对应的版本。
</description>
</MySQLVariableDescription>


 <MySQLVariableDescription>
	<variable_name>Sort_range</variable_name>
	<description>查询做排序，不论是因为 order by 还是 group by（除了使用了 order by NULL 的 group by），主要都是下面的三步：
1. 通过 where 条件找到记录
2. 排序
3. 按排好的顺序读取记录
如果第二步不被跳过，那么第三步中就会有 Sort_scan 或 Sort_range。如果第一步是 Select_scan，那么第三步将是 Sort_scan，如果第一步是 Select_range，
那么第三步会是 Sort_range。
但 Sort_scan 和 Sort_range 其实没有功能上的区别，都是将需要的记录按顺序读出来，所以性能也是一样的。</description>
</MySQLVariableDescription>


 <MySQLVariableDescription>
	<variable_name>Select_full_range_join</variable_name>
	<description>和 Select_range_check 类似，不过 MySQL 可以肯定它能够使用范围查找。这时 explain 中的类型是 range。这也可能是有一些性能问题的。</description>
</MySQLVariableDescription>


 <MySQLVariableDescription>
	<variable_name>Sort_merge_passes</variable_name>
	<description>排序算法已经执行的合并的数量。如果这个变量值较大，应考虑增加sort_buffer_size系统变量的值。Sort_merge_passes 包括两步。MySQL 首先会尝试在内存中做排序，使用的内存大小由系统变量 Sort_buffer_size 决定，如果它的大小不够把所有的记录都读到内存中，
MySQL 就会把每次在内存中排序的结果存到临时文件中，等 MySQL 找到所有记录之后，再把临时文件中的记录做一次排序。
这再次排序就会增加 Sort_merge_passes。实际上，MySQL 会用另一个临时文件来存再次排序的结果，所以通常会看到 Sort_merge_passes 增加的数值是建临时文件数的两倍。
因为用到了临时文件，所以速度可能会比较慢，增加 Sort_buffer_size 会减少 Sort_merge_passes 和 创建临时文件的次数。
但盲目的增加 Sort_buffer_size 并不一定能提高速度</description>
</MySQLVariableDescription>

<MySQLVariableDescription>
	<variable_name>Slow_launch_threads</variable_name>
	<description>记录是否有否超过slow_launch_time秒创建线程的数目。</description>
</MySQLVariableDescription>


<MySQLVariableDescription>
	<variable_name>Slave_retried_transactions</variable_name>
	<description>启动后复制从服务器SQL线程尝试事务的总次数。</description>
</MySQLVariableDescription>

<MySQLVariableDescription>
	<variable_name>Slave_open_temp_tables</variable_name>
	<description>当前由从SQL线程打开的临时表的数量。</description>
</MySQLVariableDescription>

<MySQLVariableDescription>
	<variable_name>Open_streams</variable_name>
	<description>打开的流的数量(主要用于记录)。。</description>
</MySQLVariableDescription>


<!-- -
Com_backup_table
Com_begin
Com_call_procedure
Com_change_db
Com_change_master
Com_check
Com_checksum
Com_commit
Com_create_db
Com_create_function
Com_create_index
Com_create_table
Com_create_user
Com_dealloc_sql
Com_delete
Com_delete_multi
Com_do
Com_drop_db
Com_drop_function
Com_drop_index
Com_drop_table
Com_drop_user
Com_execute_sql
Com_flush
Com_grant
Com_ha_close
Com_ha_open
Com_ha_read
Com_help
Com_insert
Com_insert_select
Com_kill
Com_load
Com_load_master_data
Com_load_master_table
Com_lock_tables
Com_optimize
Com_preload_keys
Com_prepare_sql
Com_purge
Com_purge_before_date
Com_rename_table
Com_repair
Com_replace
Com_replace_select
Com_reset
Com_restore_table
Com_revoke
Com_revoke_all
Com_rollback
Com_savepoint
Com_select
Com_set_option
Com_show_binlog_events
Com_show_binlogs
Com_show_charsets
Com_show_collations
Com_show_column_types
Com_show_create_db
Com_show_create_table
Com_show_databases
Com_show_errors
Com_show_fields
Com_show_grants
Com_show_keys
Com_show_logs
Com_show_master_status
Com_show_ndb_status
Com_show_new_master
Com_show_open_tables
Com_show_privileges
Com_show_processlist
Com_show_slave_hosts
Com_show_slave_status
Com_show_status
Com_show_storage_engines
Com_show_tables
Com_show_triggers
Com_show_variables
Com_show_warnings
Com_slave_start
Com_slave_stop
Com_stmt_close
Com_stmt_execute
Com_stmt_fetch
Com_stmt_prepare
Com_stmt_reset
Com_stmt_send_long_data
Com_truncate
Com_unlock_tables
Com_update
Com_update_multi
Com_xa_commit
Com_xa_end
Com_xa_prepare
Com_xa_recover
Com_xa_rollback
Com_xa_start
-->


<!--
 
 









 -->





</list>